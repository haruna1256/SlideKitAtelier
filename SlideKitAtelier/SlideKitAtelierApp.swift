//
//  SlideKitAtelierApp.swift
//
//  This file is automatically generated by SlideGen
//

import SwiftUI
import SlideKit

@main
struct SlideKitAtelierApp: App {

    // RemoteオブジェクトはApp全体で一貫して使用
    @StateObject private var remote = Remote()
    private static let configuration = SlideConfiguration()

    // SlideIndexControllerをラップ
    @StateObject private var slideWrapper: SlideControllerWrapper

    init() {
        let wrapper = SlideControllerWrapper(controller: Self.configuration.slideIndexController)
        _slideWrapper = StateObject(wrappedValue: wrapper)
    }

    // SlideIndexControllerへの参照を容易にするためにComputed Propertyとして保持
    private var slideIndexController: SlideIndexController {
        slideWrapper.controller
    }

    var presentationContentView: some View {
        SlideRouterView(slideIndexController: slideIndexController)
    }

    // SlideIndexControllerが変更された際にリモート送信を行うためのView (macOS Presenter Window用)
    private func RemoteSenderView<Content: View>(@ViewBuilder content: () -> Content) -> some View {
        content()
            // 絶対ステップが変更されるたびにリモート送信
            .onReceive(slideWrapper.$absoluteStep.removeDuplicates()) { step in
                // 同期中の変更は送信しない（無限ループ防止）
                guard !slideWrapper.isSyncing else {
                    return
                }
                remote.sendSlideIndex(step)
            }
    }

    var body: some Scene {
        // メインのプレゼンテーションウィンドウ (iOSでは操作面、macOSでは表示面)
        WindowGroup {
            PresentationView(slideSize: Self.configuration.size) {
                presentationContentView
            }
            // リモート受信処理を有効にする
            .onAppear {
                remote.onReceiveSlideIndex = { step in
                    Task { @MainActor in
                        slideWrapper.syncTo(absoluteStep: step)
                    }
                }
            }

            // 絶対ステップの変更を監視してリモート送信
            .onReceive(slideWrapper.$absoluteStep.removeDuplicates()) { step in
                // 同期中の変更は送信しない（無限ループ防止）
                guard !slideWrapper.isSyncing else {
                    return
                }
                remote.sendSlideIndex(step)
            }

            #if os(iOS)
            // iOSでのスワイプ操作によるローカルナビゲーション
            .highPriorityGesture(
                DragGesture(minimumDistance: 50)
                    .onEnded { value in
                        if value.translation.width < 0 {
                            // 左スワイプ: 次へ
                            slideWrapper.forward()
                        } else if value.translation.width > 0 {
                            // 右スワイプ: 前へ
                            slideWrapper.back()
                        }
                    }
            )
            #endif
        }

        #if os(macOS)
        .setupAsPresentationWindow(slideIndexController) {
            NSWorkspace.shared.open(URL(string: "SlideKitAtelier://editor")!)
        }
        .addPDFExportCommands(
            for: presentationContentView,
            with: slideIndexController,
            size: Self.configuration.size
        )
        #endif

        #if os(macOS)
        // 発表者用画面（macOSのみ）
        WindowGroup {
            // macOSの発表者ビューでの操作でもインデックスを送信する
            RemoteSenderView {
                macOSPresenterView(
                    slideSize: Self.configuration.size,
                    slideIndexController: slideIndexController
                ) {
                    presentationContentView
                }
            }
        }
        .setupAsPresenterWindow()
        #endif
    }
}

// iOS用の簡易発表者ビュー（オプション） 
#if os(iOS)
struct iOSPresenterView: View {
    let slideSize: CGSize
    @ObservedObject var slideIndexController: SlideIndexController

    init<Content: View>(slideSize: CGSize, slideIndexController: SlideIndexController, @ViewBuilder content: () -> Content) {
        self.slideSize = slideSize
        self.slideIndexController = slideIndexController
        self.presentationContent = AnyView(content())
    }

    let presentationContent: AnyView

    var body: some View {
        VStack {
            Text("スライド \(slideIndexController.currentIndex + 1)")
                .font(.headline)
                .padding()

            PresentationView(slideSize: slideSize) {
                presentationContent
            }
            .frame(maxWidth: 300)
            .border(Color.gray)

            HStack {
                Button(action: {
                    slideIndexController.back()
                }) {
                    Image(systemName: "chevron.left")
                        .font(.title)
                        .padding()
                }
                .disabled(slideIndexController.currentIndex == 0)

                Spacer()

                Button(action: {
                    slideIndexController.forward()
                }) {
                    Image(systemName: "chevron.right")
                        .font(.title)
                        .padding()
                }
            }
            .padding()
        }
    }
}
#endif
